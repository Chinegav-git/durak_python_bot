### Принципы работы

1.  **Язык коммуникации:** Думай на английском, но все ответы и комментарии предоставляй на **украинском языке**.

2.  **Обязательное логирование изменений:** Любые изменения в коде, конфигурации или документации должны быть отражены в файле `CHANGELOG.md`. Внесение записи в этот файл — **это всегда последнее действие**, завершающее работу над задачей.
    *   **Принцип группировки:** Вся работа, выполненная в рамках одной логической сессии (например, исправление набора багов и последующее обновление документации), должна быть сгруппирована под **одним, новым номером версии** в `CHANGELOG.md`.

3.  **План действий:** Для правок, затрагивающих несколько файлов или имеющих сложную логику, сначала представь краткий план. Приступай к реализации только после одобрения.

4.  **Форматирование и стиль кода:** Весь код должен соответствовать стандартам `black` для форматирования и `flake8` для линтинга.

5.  **Техническая конкретика:** В своих ответах и записях для `CHANGELOG.md` избегай расплывчатых, "водянистых" формулировок. Будь технически точным и конкретным.

6.  **Принцип финальной само-верификации:** Перед тем как объявить задачу выполненной, я обязан провести внутреннюю проверку по следующему чеклисту, чтобы гарантировать качество и полноту работы:
    *   `[ ]` **Проблема решена? (Честная проверка)**: Решил ли я проблему? Я не могу запустить код, поэтому "решено" для меня означает: я провел полный **статический анализ** всех моих изменений, отследил их влияние на другие части кода, проверил все пути импортов и убедился, что логика корректна. **Я не делаю вид, что проводил реальное тестирование.**
    *   `[ ]` **Нет лишних правок?** Не предложил ли я ненужных изменений, которые не относятся к текущей задаче (как было с `game_manager.py`)?
    *   `[ ]` **Стиль соблюден?** Соответствует ли мой код стандартам (правило №4)? Соответствуют ли мои записи в `CHANGELOG.md` стилю предыдущих записей (правило №5)?
    *   `[ ]` **Все инструкции выполнены?** Перечитал ли я правила с №1 по №5 и убедился ли, что все они выполнены?
    *   `[ ]` **CHANGELOG.md обновлен?** Является ли обновление `CHANGELOG.md` моим последним действием (правило №2)?

7.  **Принцип прозорості та безпеки змін:** Коли я пропоную зміни в коді, я зобов'язаний не просто запропонувати код, а й коротко пояснити **суть виправлення** та **його вплив на систему**. Моє пояснення має включати:
    *   **Що саме виправляється:** Чітке пояснення причини помилки.
    *   **Чому це безпечно:** Оцінка "радіусу вибуху" — чи є зміни локальними, чи можуть вони вплинути на інші частини системи.

    Це дасть вам змогу швидко оцінити адекватність моїх дій і з більшою впевненістю схвалювати їх.

# Telegram-бот для игры в "Дурака"
Это Telegram-бот для игры в карточную игру "Дурак".
## Установка и запуск
1.  **Установите зависимости:**

    ```bash
    pip install -r requirements.txt
    ```
2.  **Настройте переменные окружения:**
    Создайте файл `.env` в корневой директории проекта и добавьте в него следующие переменные:
    ```
    BOT_TOKEN=ВАШ_ТОКЕН_БОТА
    ADMINS=ВАШ_ТЕЛЕГРАМ_ID
    ```
    *   `BOT_TOKEN`: токен вашего Telegram-бота.
    *   `ADMINS`: ваш Telegram ID в качестве администратора бота.

3.  **Запустите бота:**

    ```bash
    python bot.py
    ```
    Или воспользуйтесь скриптами для запуска:
    *   Для Windows: `start.bat`
    *   Для Linux/macOS: `start.sh`

## Налаштування команд бота
Щоб у меню вашого бота в Telegram відображався список доступних команд, їх потрібно налаштувати за допомогою **@BotFather**.

1.  Відкрийте діалог з **@BotFather** у Telegram.
2.  Надішліть команду `/mybots` і виберіть вашого бота.
3.  Натисніть **"Edit Bot"** -> **"Edit Commands"**.
4.  **@BotFather** попросить вас надіслати список команд у форматі `command1 - description`.
5.  Скопіюйте весь вміст файлу `commands.txt`, який знаходиться в кореневій директорії проекту, і надішліть його як відповідь.

Цей файл містить усі актуальні команди та їх описи українською мовою.

## Управління режимами гри

Бот підтримує кілька режимів відображення гри, що дозволяє адаптувати його зовнішній вигляд під ваші вподобання. Налаштування зберігаються для кожного чату окремо.

### Доступні режими:

*   `text` (за замовчуванням): Класичний режим, де всі дії в грі описуються виключно текстовими повідомленнями. Це забезпечує максимальну сумісність і мінімалістичний вигляд.
*   `text_and_sticker`: У цьому режимі під час атаки бот додатково надсилає стікер карти, яку було підкинуто. Це робить гру більш наочною. Стікер автоматично видаляється, коли карту побито або взято.
*   `sticker_and_button`: Мінімалістичний режим, в якому бот надсилає лише стікер атакуючої карти та кнопку для відповіді, без супровідного тексту.

### Команда `/gamemode`

Для управління режимами використовується команда `/gamemode`.

*   **Як використовувати:**
    *   Щоб переглянути поточний режим та список доступних, надішліть команду без аргументів: `/gamemode`
    *   Щоб змінити режим, вкажіть його назву як аргумент. Команда має вигляд: `/gamemode [назва_режиму]`.
    *   Наприклад: `/gamemode text_and_sticker`

Зміна режиму відбувається миттєво і застосовується до поточної гри.

## Работа с Git

### Отправка изменений
При отправке изменений в удаленный репозиторий, если имя локальной ветки отличается от имени удаленной, используйте следующую команду:

```bash
git push origin HEAD
```

Эта команда отправит вашу текущую ветку (`HEAD`) на удаленный сервер (`origin`), создав там ветку с таким же именем.

## Основные библиотеки

*   **`aiogram 2.25.1`**: Асинхронный фреймворк, являющийся основой бота. Он обрабатывает все взаимодействия с Telegram API: получение сообщений, обработку команд, отправку ответов и управление инлайн-клавиатурами.
*   **`Pony ORM 0.7.19`**: Мощная Object-Relational Mapper для работы с базой данных SQLite. Используется для хранения и управления настройками и статистикой пользователей (`UserSetting`), а також налаштуваннями чатів (`ChatSetting`).
*   **`environs 9.5.0`**: Библиотека для удобной работы с переменными окружения. Позволяет безопасно загружать конфигурационные данные (токен, ID администраторов) из `.env` файла.
*   **`black` и `flake8`**: Инструменты для обеспечения качества кода. `black` автоматически форматирует код в едином стиле, а `flake8` проверяет его на соответствие стандартам PEP 8 и находит потенциальные ошибки.

## Инструменты для разработки

### Получение `file_id` для стикеров

Для обновления или добавления стикеров карт в `durak/objects/card.py` необходим их `file_id`.
Был добавлен временный обработчик, который позволяет администраторам легко получать эти ID.

**Как использовать:**

1.  Убедитесь, что бот запущен.
2.  Откройте личный чат с ботом.
3.  Отправьте боту любой стикер.
4.  Бот немедленно ответит сообщением, содержащим `file_id` этого стикера.

Этот функционал доступен только пользователям, чей ID указан в списке `ADMINS`.

**Важно:** Этот инструмент предназначен только для разработки. После того, как все необходимые `file_id` будут получены и добавлены в код, рекомендуется удалить файл `durak/handlers/info/get_sticker_id.py` и соответствующую строку импорта из `durak/handlers/info/__init__.py` для поддержания чистоты кодовой базы.

## Управление темами карт (Card Themes)

Бот поддерживает систему тем, позволяющую легко изменять внешний вид карт. Темы хранятся в виде отдельных Python-файлов в директории `durak/objects/decks/`.

### Как добавить новую тему

1.  **Создайте новый файл** в директории `durak/objects/decks/` (например, `my_theme.py`). В качестве основы можно скопировать существующую тему, например `classic.py` или `green_trumps.py`.

2.  **Определите словарь `THEME`** в этом файле. Этот словарь должен содержать четыре обязательных ключа, каждый из которых является словарем с `file_id` стикеров для карт:
    *   `'normal'`: Обычное состояние карты.
    *   `'grey'`: Состояние карты, когда ею нельзя походить (например, в руке другого игрока).
    *   `'trump_normal'`: Состояние для козырной карты.
    *   `'trump_grey'`: Состояние для козырной карты, которой нельзя походить.

    **Пример структуры файла `my_theme.py`:**
    ```python
    THEME = {
        'normal': {
            '6_d': 'ID_СТИКЕРА_ТУТ',
            # ... остальные карты
        },
        'grey': {
            '6_d': 'ID_СТИКЕРА_ТУТ',
            # ... остальные карты
        },
        'trump_normal': {
            '6_d': 'ID_ДРУГОГО_СТИКЕРА_ДЛЯ_КОЗЫРЯ',
            # ... остальные козырные карты
        },
        'trump_grey': {
            '6_d': 'ID_ДРУГОГО_СЕРОГО_СТИКЕРА_ДЛЯ_КОЗЫРЯ',
            # ... остальные серые козырные карты
        }
    }
    ```

3.  **Активируйте тему.** Чтобы установить вашу новую тему по умолчанию, измените значение переменной `ACTIVE_THEME` в файле `durak/objects/card.py`:

    ```python
    ACTIVE_THEME = 'my_theme'  # Замените 'my_theme' на имя вашего файла (без .py)
    ```

После этого бот автоматически загрузит новую тему при следующем запуске.

## Структура проекта

*   `main.py`: Файл-заглушка. На данный момент содержит только тестовый вывод в консоль и не используется в основной логике бота.
*   `bot.py`: Основная точка входа в приложение. Этот файл отвечает за запуск и первоначальную настройку Telegram-бота. Он импортирует и регистрирует все обработчики команд, устанавливает команды меню бота и запускает `polling` для получения обновлений от Telegram.
*   `loader.py`: Важный файл для инициализации ключевых компонентов. Он создает и настраивает подключение к базе данных, инициализирует `GameManager` для управления игровыми сессиями, а также создает единые экземпляры бота (`Bot`) и диспетчера (`Dispatcher`) из библиотеки `aiogram`, которые затем используются во всем приложении.
*   `config.py`: Центральный файл конфигурации. Он загружает переменные окружения (токен, ID администраторов) с помощью `python-dotenv`, определяет игровые константы (время ожидания, макс. игроков) и перечисляет все команды бота в удобной структуре `Commands` для автодополнения и управления.
*   `commands.txt`: Файл, що містить список команд для налаштування в **@BotFather**.
*   `requirements.txt`: Стандартный файл, перечисляющий все библиотеки Python, необходимые для работы проекта. Установка зависимостей производится командой `pip install -r requirements.txt`.
*   `pyproject.toml`: Файл конфигурации для инструментов разработки Python. В данном проекте он используется для настройки форматера `black` и линтера `flake8`, обеспечивая единый стиль кода.
*   `start.bat`: Простой пакетный скрипт для запуска бота в операционных системах Windows. Устанавливает заголовок окна консоли и выполняет `python bot.py`.
*   `start.sh`: Shell-скрипт для запуска бота в Unix-подобных системах (Linux, macOS). Делает то же самое, что и `.bat` версия, но с использованием синтаксиса bash.
*   `durak/`: Главный пакет, содержащий всю бизнес-логику игры "Дурак".
    *   `db/`: Модули для работы с базой данных с использованием Pony ORM.
        *   `__init__.py`: Экспортирует модели `UserSetting`, `ChatSetting` и объект `session` для удобного импорта в других частях приложения.
        *   `database.py`: Создает и экспортирует синглтон `db = Database()` от Pony ORM, который представляет собой подключение к базе данных. Также экспортирует `session`, являющийся псевдонимом для `db_session`, который используется для работы с сессиями базы данных.
        *   `user_settings.py`: Определяет сущность (модель) `UserSetting` для базы данных. Эта модель хранит настройки и статистику игрока, включая его Telegram ID, количество побед, сыгранных игр и другие игровые метрики.
        *   `chat_settings.py`: Определяет сущность (модель) `ChatSetting` для бази даних. Ця модель зберігає налаштування відображення гри для кожного окремого чату.
    *   `handlers/`: Обработчики команд и callback-запросов от пользователей в Telegram.
        *   `game_mode.py`: Реалізує команду `/gamemode`, що дозволяє творцю гри змінювати режим відображення. Підтримує три режими: `text`, `text_and_sticker` та `sticker_and_button`.
        *   `game/`: Обработчики, отвечающие за игровой процесс. Каждый файл обрабатывает определенную команду или действие:
            *   `admin.py`: Содержит обработчики для команд, доступных только администраторам бота, такие как `/test_win` для отладки и принудительного завершения игры.
            *   `auto_leave.py`: Автоматически удаляет из игры участника, покинувшего Telegram-группу.
            *   `callback_handlers.py`: Обрабатывает нажатия на инлайн-кнопки "Присоединиться" и "Начать игру".
            *   `chosing.py`: Основной файл для взаимодействия с игроком во время хода. Через инлайн-режим показывает карты и доступные действия (атака, защита, пас).
            *   `global_leave.py`: Реализует команду `/gleave` для выхода из игры, даже если команда отправлена из другого чата.
            *   `join.py`: Обрабатывает команду `/join` для входа в игровое лобби.
            *   `join_inline.py`: Отвечает за обработку нажатия на инлайн-кнопку "Присоединиться".
            *   `kick.py`: Обрабатывает команду `/kick` для исключения игрока из игры.
            *   `kill.py`: Реализует команду `/kill` для досрочного завершения игры создателем или администратором.
            *   `leave.py`: Обрабатывает команду `/leave` для выхода игрока из текущей игры.
            *   `new.py`: Создает новую игру в чате по команде `/new` и предлагает кнопки для присоединения и старта.
            *   `process_chosen.py`: Обрабатывает выбор игрока в инлайн-режиме (атака, защита, пас), применяет игровую логику и содержит анти-чит систему.
            *   `start.py`: Запускает игру по команде `/start`, проверяя права пользователя и количество игроков.
            *   `start_inline.py`: Отвечает за обработку нажатия на инлайн-кнопку "Почати гру".
        *   `info/`: Обработчики для информационных запросов.
            *   `help.py`: Отвечает на команды `/help` и `/start_bot`, отправляя подробное руководство по игре. Описывает шаги для начала игры, правила взаимодействия через инлайн-режиме и перечисляет основные команды, включая управление игрой и статистикой.
            *   `stats.py`: Управляет статистикой игроков. Обрабатывает команду `/stats` для отображения статистики (победы, количество игр, процент побед), а также команды `/on_stats` и `/off_stats` для включения или отключения сбора статистики для пользователя.
    *   `logic/`: Ключевая бизнес-логика игры.
        *   `game_manager.py`: Реализует класс `GameManager`, который служит центральным хранилищем и менеджером всех активных игровых сессий. Он управляет созданием (`new_game`), поиском (`get_game_from_chat`), завершением (`end_game`), присоединением игроков (`join_in_game`) и запуском (`start_game`) игр. Также содержит специфическую логику для административных действий, например `test_win_game`.
        *   `actions.py`: Содержит асинхронные функции, которые управляют основными действиями в игре. Отвечает за полный цикл хода (`do_turn`), обработку победы игрока (`win`), выход игрока из игры (`do_leave_player`), пас (`do_pass`), взятие карт со стола (`do_draw`), а также логику атаки (`do_attack_card`) и защиты (`do_defence_card`). Этот модуль является ядром игровой механики.
        *   `result.py`: Отвечает за формирование `InlineQueryResult` для ответов в инлайн-режиме Telegram. Этот модуль создает визуальные элементы, с которыми взаимодействует игрок: отображение карт (играбельных и неактивных), кнопок "Пас" (`add_pass`), "Взять" (`add_draw`), а также информационных сообщений о состоянии игры (`add_gameinfo`, `add_no_game`).
        *   `utils.py`: Набор вспомогательных функций-утилит, в основном предназначенных для проверки прав доступа. Включает функции для проверки, является ли пользователь создателем игры (`user_is_creator`), администратором бота (`user_is_bot_admin`) или администратором чата (`user_is_admin`).
    *   `objects/`: Классы, описывающие основные сущности (модели данных) игры.
        *   `card.py`: Определяет класс `Card` для представления игральной карты, а также перечисления (Enum) для мастей (`Suits`, `SuitsIcons`) и достоинств (`Values`). **Содержит механизм динамической загрузки тем карт**, что позволяет легко изменять их внешний вид. Также включает вспомогательную функцию `from_str` для создания объекта `Card` из строки.
        *   `decks/`: Новая директория, содержащая файлы тем для карт. Каждая тема - это `.py` файл со словарем `THEME`.
        *   `deck.py`: Реализует класс `Deck`, управляющий игровой колодой. Отвечает за создание стандартной колоды, её тасование (`shuffle`), определение козыря (`_set_trump`), раздачу карт (`draw`) и сброс отбитых карт (`dismiss`).
        *   `errors.py`: Содержит определения кастомных классов исключений (например, `DeckEmptyError`, `NoGameInChatError`), которые используются для обработки специфических игровых ситуаций и ошибок. Это помогает сделать логику более предсказуемой и управляемой.
        *   `game.py`: Содержит класс `Game` — ядро одной игровой сессии. Этот класс управляет всем состоянием игры: отслеживает игроков (`players`), колоду (`deck`), карты на игровом поле (`field`), козырь (`trump`), а также очередность ходов. Методы класса отвечают за старт игры, атаку (`attack`), защиту (`defend`), переход хода (`turn`) и пополнение рук игроков.
        *   `player.py`: Реализует класс `Player`, представляющий участника игры. Хранит информацию о пользователе Telegram (`user`) и его картах в руке (`cards`). Содержит ключевую логику для определения доступных для хода карт (`playable_card_atk`, `playable_card_def`) и правил, по которым одна карта может побить другую (`can_beat`).
*   `documentation/`: Папка с документацией проекта.
    *   `instructions.md`: Этот самый файл с инструкциями.
*   `img/`: Папка для хранения всех графических ассетов, используемых в боте. Изображения напрямую не встраиваются в код, но их идентификаторы (file_id) кешируются в `durak/objects/card.py` для быстрой отправки в виде стикеров.
    *   `logo_sticker_pack.png`: Основное изображение для стикерпака бота.
    *   `sprites.png`, `sprites_lowsat.png`: Спрайт-листы, объединяющие изображения всех карт в один файл. `lowsat` версия — с пониженной насыщенностью, используется для отображения неактивных или уже сыгранных карт.
    *   `sprite_512px/`: Содержит отдельные файлы изображений для каждой карты в высоком разрешении (512x512 пикселей).
    *   `sprites_512px_lowsat/`: Аналогично предыдущей, но с изображениями карт с пониженной насыщенностью.
    *   `special/`: Изображения для специальных игровых действий, таких как "Взять" (`draw.png`) или "Пас".

## Управление стикерами карт
Все изображения в игре, включая карты, колоду и специальные действия, представлены в виде Telegram-стикеров. Идентификаторы (`file_id`) этих стикеров хранятся в файле `durak/objects/card.py`.

Чтобы добавить или обновить изображение для карты, выполните следующие шаги:

1.  **Отправьте изображение боту**: Отправьте изображение (как фото, не как файл) в личные сообщения боту от имени администратора.
2.  **Получите `file_id`**: Бот в ответ пришлет вам сообщение, содержащее `file_id` для этого изображения.
3.  **Обновите код**: Скопируйте полученный `file_id` и вставьте его в соответствующее место в файле `durak/objects/card.py`.

    *   Для обычных карт: `CARDS['normal']`
    *   Для "серых" (неактивных) карт: `CARDS['grey']`
    *   Для изображений колоды: `DECK`
    *   Для изображений мастей: `SUIT`
    *   Для специальных действий (`Взять`, `Пас`): `SPECIAL`

Например, чтобы обновить изображение для шестерки бубен, найдите ключ `'6_d'` в словаре `CARDS['normal']` и замените его значение на новый `file_id`.

## Стиль кода

Для поддержания чистоты и единообразия кода в этом проекте используется автоматическое форматирование с помощью `black` и проверка стиля с помощью `flake8`.

## Планы на будущее

*   Добавить новые игровые режимы.
*   Улучшить искусственный интеллект ботов.
*   Добавить возможность настройки правил игры.

## Логирование и история изменений

### История изменений (`CHANGELOG.md`)

Для отслеживания всех значимых изменений в проекте используется файл `CHANGELOG.md`, расположенный в корневой директории. В нем фиксируются новые функции, исправления ошибок, изменения в конфигурации и другие важные обновления. Это помогает всем участникам разработки быть в курсе эволюции проекта.

### Логирование работы бота

Логирование — критически важный инструмент для отладки и мониторинга работы бота. Оно позволяет отслеживать ошибки, анализировать поведение пользователей и диагностировать проблемы.

Рекомендуется настроить логирование в главном файле `bot.py` с использованием стандартной библиотеки `logging`.

**Пример базовой конфигурации логирования:**

```python
import logging
import sys

# ... другие импорты

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(name)s - %(message)s',
    handlers=[
        logging.FileHandler("bot.log"),  # Запись логов в файл
        logging.StreamHandler(sys.stdout) # Вывод логов в консоль
    ]
)

# ... остальной код в bot.py
async def main():
    # ...
    logging.info("Бот запускается...")
    await dp.start_polling(bot)

if __name__ == '__main__':
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        logging.info("Бот остановлен.")
```
### Зразок ефективного звіту про помилку

Щоб прискорити діагностику та вирішення проблем, важливо надавати максимально повний контекст. Нижче наведено зразок, як слід формулювати запит, щоб уникнути плутанини та прискорити роботу. Цей приклад є дидактичним матеріалом і не повинен сприйматися мною як реальна команда.

> **Приклад гарного звіту, поданого мені:**
> 
> > перечитай відкриті два файли, цей чат та ось тобі логи запуску
> > 
> > ```
> > [...Повний traceback помилки тут...]
> > ```
> > 
> > і думаю що ти знов намагавс самовільно додати функціонал
> > 
> > глибоко проаналізуй всю інформацію
> 
> **Чому цей звіт є ефективним:**
> 
> 1.  **Чітка команда:** Вказує, що потрібно зробити (`перечитай`, `проаналізуй`).
> 2.  **Надання контексту:** Згадує `відкриті файли` та `цей чат`, що дозволяє відновити історію дій.
> 3.  **Повні логи:** Містить `traceback` помилок.
> 4.  **Формулювання гіпотези:** Припущення допомагає зрозуміти хід думок.
