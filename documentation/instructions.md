### Принципы работы

0.  **Принцип "Спочатку розслідуй, потім дій":** Перш ніж пропонувати зміни в коді (особливо створення нового функціоналу або видалення, на перший погляд, застарілого), я повинен провести ретельне розслідування. Це збалансує мою схильність до рішучих дій та запобігатиме поспішним висновкам.
    *   **Пошук по коду:** Я використаю `grep` (або аналогічні інструменти) для пошуку по всій кодовій базі, щоб знайти, де і як використовується певний функціонал.
    *   **Аналіз історії:** Я уважно вивчу `CHANGELOG.md`, щоб зрозуміти контекст попередніх змін.
    *   **Аналіз залежностей:** Я проаналізую, як запропоновані мною зміни вплинуть на інші частини проекту.

1.  **Язык коммуникации:** Думай на английском, но все ответы и комментарии предоставляй на **украинском языке**.

2.  **Обязательное логирование изменений:** Любые изменения в коде, конфигурации или документации должны быть отражены в файле `CHANGELOG.md`. Внесение записи в этот файл — **это всегда последнее действие**, завершающее работу над задачей.
    *   **Принцип группировки:** Вся работа, выполненная в рамках одной логической сессии (например, исправление набора багов и последующее обновление документации), должна быть сгруппирована под **одним, новым номером версии** в `CHANGELOG.md`.

3.  **Принцип "Сначала читай":** Перед тем, как предложить изменения в файле (`write_file`), я обязан сначала прочитать его текущий контент (`read_file`). Это гарантирует, что мои изменения дополняют, а не уничтожают существующую информацию.

4.  **План действий:** Для правок, затрагивающих несколько файлов или имеющих сложную логику, сначала представь краткий план. Приступай к реализации только после одобрения.

5.  **Стиль коду (PEP 8):** Весь код повинен суворо відповідати стандартам **PEP 8**. Інструменти `black` та `flake8` використовуються для автоматичного форматування та перевірки відповідності цьому стандарту.

6.  **Техническая конкретика:** В своих ответах и записях для `CHANGELOG.md` избегай расплывчатых, "водянистых" формулировок. Будь технически точным и конкретным.

7.  **Принцип фінальної само-верифікації:** Перед тим як оголосити завдання виконаним, я зобов'язаний провести внутрішню перевірку за наступним чек-листом, щоб гарантувати якість і повноту роботи:
    *   `[ ]` **Проблема вирішена? (Чесна перевірка)**: Чи я вирішив проблему? Я не можу запустити код, тому "вирішено" для мене означає: я провів повний **статичний аналіз** всіх моїх змін. Цей аналіз **обов'язково** включає:
        *   **Аналіз ланцюжка викликів:** Я відстежив усі функції та методи, які прямо чи опосередковано зачіпають мої зміни.
        *   **Перевірка "контрактів" між компонентами:** Я переконався, що всі класи та функції, які взаємодіють між собою, дотримуються очікуваних "угод" (правильні імена методів, кількість та типи аргументів, наявність атрибутів).
        *   **Оцінка впливу на залежності:** Я відповів на питання: "Якщо я змінив файл А, як це вплине на файли Б і В, які його використовують?". Це особливо критично при **відкоті** файлів до старих версій або при зміні існуючого функціоналу.
    *   `[ ]` **Немає зайвих правок?** Чи не запропонував я непотрібних змін, які не належать до поточної задачі?
    *   `[ ]` **Стиль дотримано?** Чи відповідає мій код стандартам (правило №5)? Чи відповідають мої записи в `CHANGELOG.md` стилю попередніх записів (правило №9)?
    *   `[ ]` **Усі інструкції виконано?** Чи перечитав я всі правила і чи переконався, що вони виконані?
    *   `[ ]` **CHANGELOG.md оновлено?** Чи є оновлення `CHANGELOG.md` моєю останньою дією (правило №2)?

8.  **Принцип прозорості та безпеки змін:** Коли я пропоную зміни в коді, я зобов'язаний не просто запропонувати код, а й коротко пояснити **суть виправлення** та **його вплив на систему**. Моє пояснення має включати:
    *   **Що саме виправляється:** Чітке пояснення причини помилки.
    *   **Чому це безпечно:** Оцінка "радіусу вибуху" — чи є зміни локальними, чи можуть вони вплинути на інші частини системи.

    Це дасть вам змогу швидко оцінити адекватність моїх дій і з більшою впевненістю схвалювати їх.

9.  **Суворий стиль CHANGELOG.md:** При оновленні файлу `CHANGELOG.md` я зобов'язаний суворо дотримуватися стилю, тону та рівня деталізації попередніх записів. Цей файл є технічним логом для розробників, і його записи повинні бути максимально конкретними.

    **Мої записи в `CHANGELOG.md` повинні:**

    1.  **Бути технічно-конкретними:** Замість загальних описів ("покращено щось"), я маю чітко вказувати, *що саме* було змінено в коді.
    2.  **Містити посилання на код:** Якщо це доречно, я повинен включати назви змінених файлів (`durak/logic/utils.py`), функцій (`user_is_creator_or_admin`), класів або змінних.
    3.  **Відповідати існуючому формату:** Я маю аналізувати попередні записи, щоб відтворити їх структуру (наприклад, використання `### Fixed`, `### Changed`, `### Added`).

    **Приклад помилки (чого я маю уникати):**

    ```markdown
    ### Changed
    - Розширено права на старт гри, додано адмінів.
    - Зроблено повідомлення більш інформативним.
    ```

    **Приклад правильного, технічного запису (якого я маю дотримуватись):**

    ```markdown
    ### Changed
    - **Покращено обробку прав на старт гри:** В `durak/handlers/game/start.py` змінено текст повідомлення про помилку. Це покращує UX, не змінюючи існуючу логіку перевірки прав у функції `user_is_creator_or_admin`, яка вже коректно обробляла повноваження адміністраторів.
    ```

10. **Принцип чистоти кодової бази (Рекомендація):** Код, який є тимчасово непотрібним (наприклад, функціонал для тестування, як-от `test_win_game`, чи застарілі методи), не повинен залишатися в активному стані.
    *   **Примітка:** Як один із варіантів, такий код можна тимчасово "вимкнути", закоментувавши його та позначивши спеціальним тегом (наприклад, `#TODO:ADMIN` або `#TEMP:UNUSED`). Це дозволяє швидко знайти та активувати його в майбутньому, не забруднюючи основну логіку. Основною ж практикою є покладання на систему контролю версій (Git) для зберігання та відновлення такого коду.

11. **Заборона на логіку "Колективного Бито":** Категорично забороняється пропонувати та реалізовувати логіку завершення раунду ("бито"), яка залежить від дій гравців, що можуть лише підкидати карти. Завершення раунду відбувається **виключно** за рішенням **головного атакуючого** (якщо він спасував після того, як всі карти були побиті) або примусово, якщо захисник бере карти. Ця спрощена модель є ключовою для динаміки гри в боті і не повинна ускладнюватися.

12. **Принцип верифікації взаємодій:** Перед внесенням змін до файлів, необхідно провести аналіз того, як функції та компоненти взаємодіють між собою. Це включає перевірку ланцюжків викликів та "контрактів" між ними, щоб переконатися, що зміни в одному місці не порушать роботу в іншому.

13. **Примітка про "Автопас":** Для пришвидшення гри реалізовано механіку "автопасу". Якщо після того, як захисник побив карту, у головного атакуючого більше немає карт для підкидання, раунд автоматично завершується, і хід передається далі. Це правило діє навіть у грі на 3+ гравців, де інші учасники могли б теоретично підкинути свої карти. Така реалізація є свідомим рішенням для підтримки динамічного темпу гри.

# Архітектура та потік даних

В основі бота лежить багатошарова архітектура, що чітко розділяє відповідальності між компонентами. Це робить систему гнучкою, масштабованою та простою для розуміння.

**Основні шари:**

1.  **Шар представлення (Presentation Layer) - `durak/handlers/`**:
    *   **Відповідальність:** Взаємодія з користувачем через Telegram API.
    *   **Реалізація:** Цей шар складається з обробників (`handlers`) `aiogram`, які реагують на команди (`/new`, `/join`), натискання кнопок та інлайн-запити. Їхнє головне завдання — отримати запит від користувача, витягти з нього необхідні дані (ID чату, ID користувача, обрану карту) і передати управління на наступний, логічний шар. Обробники не містять складної ігрової логіки.

2.  **Шар бізнес-логіки (Business Logic Layer) - `durak/logic/`**:
    *   **Відповідальність:** Реалізація правил гри "Дурень" та керування ігровими сесіями.
    *   **Ключові компоненти:**
        *   `GameManager (`gm` з `loader.py`): Центральний сервіс, що керує всіма активними іграми. Він виступає як "точка входу" для шару представлення. `GameManager` створює, знаходить та завершує ігрові сесії.
        *   `actions.py`: Містить асинхронні функції, що реалізують конкретні ігрові дії (`do_attack`, `do_defence`, `do_pass`). Ці функції змінюють стан гри та надсилають повідомлення користувачам.
        *   `result.py`: Формує відповіді для інлайн-режиму, генеруючи список карт та кнопок, які бачить гравець.

3.  **Шар моделей даних (Data Model Layer) - `durak/objects/`**:
    *   **Відповідальність:** Опис основних ігрових сутностей у вигляді класів.
    *   **Ключові компоненти:**
        *   `Game`: Представляє одну ігрову партію. Зберігає стан гри: список гравців, колоду, карти на столі, козир, поточного атакуючого та захисника.
        *   `Player`: Представляє гравця, зберігає його карти та надає методи для перевірки ігрових можливостей (наприклад, `can_beat`).
        *   `Deck`, `Card`: Представляють колоду та окрему карту відповідно.

4.  **Шар доступу до даних (Data Access Layer) - `durak/db/`**:
    *   **Відповідальність:** Збереження та завантаження даних, що не є частиною активної ігрової сесії.
    *   **Реалізація:** Використовує `Pony ORM` для роботи з базою даних `SQLite`. Зберігає налаштування чатів (`ChatSetting`) та статистику користувачів (`UserSetting`).

### Приклад потоку даних: Хід гравця

Щоб зрозуміти взаємодію шарів, розглянемо типовий сценарій: гравець робить хід в інлайн-режимі.

1.  **Користувач** вводить `@bot_name` у чаті. Telegram надсилає `InlineQuery` на сервер.
2.  `aiogram` отримує запит і передає його обробнику **`chosing.py`** (`durak/handlers/game/`).
3.  **`chosing.py`**:
    *   Через `GameManager` (`gm`) знаходить поточну гру для цього чату.
    *   Визначає, які карти гравець може походити.
    *   Викликає функції з **`result.py`** (`durak/logic/`), щоб сформувати список `InlineQueryResult` (зображення карт та кнопки).
    *   Надсилає відповідь у Telegram.
4.  **Користувач** обирає карту зі списку. Telegram надсилає `ChosenInlineResult`.
5.  `aiogram` передає запит обробнику **`process_chosen.py`** (`durak/handlers/game/`).
6.  **`process_chosen.py`**:
    *   Витягує ID гри та обрану карту (`Card`) із `result_id`.
    *   Викликає відповідну функцію з **`actions.py`** (`durak/logic/`), наприклад, `do_attack_card()`.
7.  **`actions.py` (`do_attack_card`)**:
    *   Отримує об'єкт гри (`Game`) з `GameManager`.
    *   Викликає метод `game.attack()`, який змінює стан **об'єктів** (`Game`, `Player`).
    *   Надсилає оновлені повідомлення всім гравцям, інформуючи про хід.

Цей підхід, заснований на чіткому розподілі відповідальностей, дозволяє легко модифікувати та розширювати функціонал. Наприклад, для додавання нового правила гри достатньо внести зміни в `durak/logic/actions.py` та, можливо, в `durak/objects/game.py`, не торкаючись коду, відповідального за взаємодію з Telegram.

# Telegram-бот для игры в "Дурака"
Это Telegram-бот для игры в карточную игру "Дурак".
## Установка и запуск
1.  **Установите зависимости:**

    ```bash
    pip install -r requirements.txt
    ```
2.  **Настройте переменные окружения:**
    Создайте файл `.env` в корневой директории проекта и добавьте в него следующие переменные:
    ```
    BOT_TOKEN=ВАШ_ТОКЕН_БОТА
    ADMINS=ВАШ_ТЕЛЕГРАМ_ID
    ```
    *   `BOT_TOKEN`: токен вашего Telegram-бота.
    *   `ADMINS`: ваш Telegram ID в качестве администратора бота.

3.  **Запустите бота:**

    ```bash
    python bot.py
    ```
    Или воспользуйтесь скриптами для запуска:
    *   Для Windows: `start.bat`
    *   Для Linux/macOS: `start.sh`

## Налаштування команд бота
Щоб у меню вашого бота в Telegram відображався список доступних команд, їх потрібно налаштувати за допомогою **@BotFather**.

1.  Відкрийте діалог з **@BotFather** у Telegram.
2.  Надішліть команду `/mybots` і виберіть вашого бота.
3.  Натисніть **"Edit Bot"** -> **"Edit Commands"**.
4.  **@BotFather** попросить вас надіслати список команд у форматі `command1 - description`.
5.  Скопіюйте весь вміст файлу `commands.txt`, який знаходиться в кореневій директорії проекту, і надішліть його як відповідь.

Цей файл містить усі актуальні команди та їх описи українською мовою.

## Управління режимами гри

Бот підтримує кілька режимів відображення гри, що дозволяє адаптувати його зовнішній вигляд під ваші вподобання. Налаштування зберігаються для кожного чату окремо.

### Доступні режими:

*   `text` (за замовчуванням): Класичний режим, де всі дії в грі описуються виключно текстовими повідомленнями. Це забезпечує максимальну сумісність і мінімалістичний вигляд.
*   `text_and_sticker`: У цьому режимі під час атаки бот додатково надсилає стікер карти, яку було підкинуто. Це робить гру більш наочною. Стікер автоматично видаляється, коли карту побито або взято.
*   `sticker_and_button`: Мінімалістичний режим, в якому бот надсилає лише стікер атакуючої карти та кнопку для відповіді, без супровідного тексту.

### Команда `/gamemode`

Для управління режимами використовується команда `/gamemode`.

*   **Як використовувати:**
    *   Щоб переглянути поточний режим та список доступних, надішліть команду без аргументів: `/gamemode`
    *   Щоб змінити режим, вкажіять його назву як аргумент. Команда має вигляд: `/gamemode [назва_режиму]`.
    *   Наприклад: `/gamemode text_and_sticker`

Зміна режиму відбувається миттєво і застосовується до поточної гри.

## Управління темами карт (`/theme`)

Бот підтримує систему тем, що дозволяє змінювати зовнішній вигляд карт (стікерів). Налаштування зберігаються для кожного чату окремо.

### Доступні теми:

*   `classic` (за замовчуванням): Класична тема стікерів.
*   `gold_trumps`: Тема, в якій козирні карти мають золоте оформлення.

### Команда `/theme`

Для управління темами використовується команда `/theme`.

*   **Як використовувати:**
    *   Надішліть команду `/theme` в чаті, де ви граєте.
    *   Бот запропонує вам обрати одну з доступних тем за допомогою інлайн-клавіатури.

Зміна теми відбувається миттєво і буде застосована до всіх наступних дій в грі в цьому чаті.

## Работа с Git

### Стиль повідомлень для коммітів

Кожен комміт повинен мати стисле та інформативне повідомлення, що відповідає конвенції **Conventional Commits** та включає версію з `CHANGELOG.md`.

**Формат:** `[vX.X.XX] тип: Короткий опис англійською`

*   **Версія:** На початку повідомлення завжди вказується номер версії з `CHANGELOG.md` у квадратних дужках.
*   **Типи:**
    *   `feat`: Додавання нової функціональності.
    *   `fix`: Виправлення помилки.
    *   `refactor`: Зміни в коді, що не виправляють помилок і не додають функціональності.
    *   `docs`: Зміни в документації.
    *   `style`: Виправлення форматування, стилю коду.
    *   `chore`: Інші зміни, що не стосуються коду (напр., оновлення залежностей).

**Приклад:** `[v1.2.22] feat: Add game end logic and refactor game_manager`

### Отправка изменений
При отправке изменений в удаленный репозиторий, если имя локальной ветки отличается от имени удаленной, используйте следующую команду:

```bash
git push origin HEAD
```

Эта команда отправит вашу текущую ветку (`HEAD`) на удаленный сервер (`origin`), создав там ветку с таким же именем.

## Основные библиотеки

*   **`aiogram 2.25.1`**: Асинхронный фреймворк, являющийся основой бота. Он обрабатывает все взаимодействия с Telegram API: получение сообщений, обработку команд, отправку ответов и управление инлайн-клавиатурами.
*   **`Pony ORM 0.7.19`**: Мощная Object-Relational Mapper для работы с базой данных SQLite. Используется для хранения и управления настройками и статистикой пользователей (`UserSetting`), а також налаштуваннями чатів (`ChatSetting`).
*   **`environs 9.5.0`**: Библиотека для удобной работы с переменными окружения. Позволяет безопасно загружать конфигурационные данные (токен, ID администраторов) из `.env` файла.
*   **`black` и `flake8`**: Инструменты для обеспечения качества кода. `black` автоматически форматирует код в едином стиле, а `flake8` проверяет его на соответствие стандартам PEP 8 и находит потенциальные ошибки.

## Инструменты для разработки

### Получение `file_id` для стикеров

Для обновления или добавления стикеров карт в `durak/objects/card.py` необходим их `file_id`.
Был добавлен временный обработчик, который позволяет администраторам легко получать эти ID.

**Как использовать:**

1.  Убедитесь, что бот запущен.
2.  Откройте личный чат с ботом.
3.  Отправьте боту любой стикер.
4.  Бот немедленно ответит сообщением, содержащим `file_id` этого стикера.

Этот функционал доступен только пользователям, чей ID указан в списке `ADMINS`.

**Важно:** Этот инструмент предназначен только для разработки. После того, как все необходимые `file_id` будут получены и добавлены в код, рекомендуется удалить файл `durak/handlers/info/get_sticker_id.py` и соответствующую строку импорта из `durak/handlers/info/__init__.py` для поддержания чистоты кодовой базы.

## Як додати нову тему карт

Бот підтримує систему тем, що дозволяє легко змінювати зовнішній вигляд карт. Теми зберігаються у вигляді окремих Python-файлів у директорії `durak/objects/decks/`.

1.  **Створіть новий файл** в директорії `durak/objects/decks/` (наприклад, `my_theme.py`). В якості основи можна скопіювати існуючу тему, наприклад `classic.py` або `gold_trumps.py`.

2.  **Оголосіть словник `THEME`** у цьому файлі. Цей словник повинен містити чотири обов'язкові ключі, кожен з яких є словником з `file_id` стікерів для карт:
    *   `'normal'`: Звичайний стан карти.
    *   `'grey'`: Стан карти, коли нею не можна походити.
    *   `'trump_normal'`: Стан для козирної карти.
    *   `'trump_grey'`: Стан для козирної карти, якою не можна походити.

    **Приклад структури файлу `my_theme.py`:**
    ```python
    THEME = {
        'normal': {
            '6_d': 'ID_СТИКЕРА_ТУТ',
            # ... решта карт
        },
        'grey': {
            '6_d': 'ID_СТИКЕРА_ТУТ',
            # ... решта карт
        },
        'trump_normal': {
            '6_d': 'ID_ІНШОГО_СТИКЕРА_ДЛЯ_КОЗИРЯ',
            # ... решта козирних карт
        },
        'trump_grey': {
            '6_d': 'ID_ІНШОГО_СІРОГО_СТИКЕРА_ДЛЯ_КОЗИРЯ',
            # ... решта сірих козирних карт
        }
    }
    ```

3.  **Тема готова!** Нова тема стане доступною для вибору через команду `/theme` автоматично. Бот динамічно знаходить усі файли тем у директорії `durak/objects/decks/`.

## Структура проекту

*   `main.py`: Файл-заглушка. На данный момент содержит только тестовый вывод в консоль и не используется в основной логике бота.
*   `bot.py`: Основная точка входа в приложение. Этот файл отвечает за запуск и первоначальную настройку Telegram-бота. Он импортирует и регистрирует все обработчики команд, устанавливает команды меню бота и запускает `polling` для получения обновлений от Telegram.
*   `loader.py`: Важный файл для инициализации ключевых компонентов. Он создает и настраивает подключение к базе данных, инициализирует `GameManager` для управления игровыми сессиями, а также создает единые экземпляры бота (`Bot`) и диспетчера (`Dispatcher`) из библиотеки `aiogram`, которые затем используются во всем приложении.
*   `config.py`: Центральный файл конфигурации. Он загружает переменные окружения (токен, ID администраторов) с помощью `python-dotenv`, определяет игровые константы (время ожидания, макс. игроков) и перечисляет все команды бота в удобной структуре `Commands` для автодополнения и управления.
*   `commands.txt`: Файл, що містить список команд для налаштування в **@BotFather**.
*   `requirements.txt`: Стандартный файл, перечисляющий все библиотеки Python, необходимые для работы проекта. Установка зависимостей производится командой `pip install -r requirements.txt`.
*   `pyproject.toml`: Файл конфигурации для инструментов разработки Python. В данном проекте он используется для настройки форматера `black` и линтера `flake8`, обеспечивая единый стиль кода.
*   `start.bat`: Простой пакетный скрипт для запуска бота в операционных системах Windows. Устанавливает заголовок окна консоли и выполняет `python bot.py`.
*   `start.sh`: Shell-скрипт для запуска бота в Unix-подобных системах (Linux, macOS). Делает то же самое, что и `.bat` версия, но с использованием синтаксиса bash.
*   `durak/`: Главный пакет, содержащий всю бизнес-логику игры "Дурак".
    *   `db/`: Модули для работы с базой данных с использованием Pony ORM.
        *   `__init__.py`: Экспортирует модели `UserSetting`, `ChatSetting` и объект `session` для удобного импорта в других частях приложения.
        *   `database.py`: Создает и экспортирует синглтон `db = Database()` от Pony ORM, который представляет собой подключение к базе данных. Также экспортирует `session`, являющийся псевдонимом для `db_session`, который используется для работы с сессиями базы данных.
        *   `user_settings.py`: Определяет сущность (модель) `UserSetting` для базы данных. Эта модель хранит настройки и статистику игрока, включая его Telegram ID, количество побед, сыгранных игр и другие игровые метрики.
        *   `chat_settings.py`: Определяет сущность (модель) `ChatSetting` для бази даних. Ця модель зберігає налаштування відображення гри (`display_mode`) та обрану тему карт (`card_theme`) для кожного окремого чату.
    *   `handlers/`: Обработчики команд и callback-запросов от пользователей в Telegram.
        *   `card_theme.py`: Реалізує команду `/theme`, що дозволяє гравцям обирати тему оформлення карт для свого чату.
        *   `game_mode.py`: Реалізує команду `/gamemode`, що дозволяє творцю гри змінювати режим відображення. Підтримує три режими: `text`, `text_and_sticker` та `sticker_and_button`.
        *   `game/`: Обработчики, отвечающие за игровой процесс. Каждый файл обрабатывает определенную команду или действие:
            *   `admin.py`: Содержит обработчики для команд, доступных только администраторам бота, такие как `/test_win` для отладки и принудительного завершения игры.
            *   `auto_leave.py`: Автоматически удаляет из игры участника, покинувшего Telegram-группу.
            *   `callback_handlers.py`: Обрабатывает нажатия на инлайн-кнопки "Присоединиться" и "Начать игру".
            *   `chosing.py`: Основной файл для взаимодействия с игроком во время хода. Через инлайн-режим показывает карты и доступные действия (атака, защита, пас).
            *   `global_leave.py`: Реализует команду `/gleave` для выхода из игры, даже если команда отправлена из другого чата.
            *   `join.py`: Обрабатывает команду `/join` для входа в игровое лобби.
            *   `join_inline.py`: Отвечает за обработку нажатия на инлайн-кнопку "Присоединиться".
            *   `kick.py`: Обрабатывает команду `/kick` для исключения игрока из игры.
            *   `kill.py`: Реализует команду `/kill` для досрочного завершения игры создателем или администратором.
            *   `leave.py`: Обрабатывает команду `/leave` для выхода игрока из текущей игры.
            *   `new.py`: Создает новую игру в чате по команде `/new` и предлагает кнопки для присоединения и старта.
            *   `process_chosen.py`: Обрабатывает выбор игрока в инлайн-режиме (атака, защита, пас), применяет игровую логику и содержит анти-чит систему.
            *   `start.py`: Запускает игру по команде `/start`, проверяя права пользователя и количество игроков.
            *   `start_inline.py`: Отвечает за обработку нажатия на инлайн-кнопку "Почати гру".
        *   `info/`: Обработчики для информационных запросов.
            *   `help.py`: Отвечает на команды `/help` и `/start_bot`, отправляя подробное руководство по игре. Описывает шаги для начала игры, правила взаимодействия через инлайн-режиме и перечисляет основные команды, включая управление игрой и статистикой.
            *   `stats.py`: Управляет статистикой игроков. Обрабатывает команду `/stats` для отображения статистики (победы, количество игр, процент побед), а также команды `/on_stats` и `/off_stats` для включения или отключения сбора статистики для пользователя.
    *   `logic/`: Ключевая бизнес-логика игры.
        *   `game_manager.py`: Реализует класс `GameManager`, который служит центральным хранилищем и менеджером всех активных игровых сессий. Он управляет созданием (`new_game`), поиском (`get_game_from_chat`), завершением (`end_game`), присоединением игроков (`join_in_game`) и запуском (`start_game`) игр. Также содержит специфическую логику для административных действий, например `test_win_game`.
        *   `actions.py`: Содержит асинхронные функции, которые управляют основными действиями в игре. Отвечает за полный цикл хода (`do_turn`), обработку победы игрока (`win`), выход игрока из игры (`do_leave_player`), пас (`do_pass`), взятие карт со стола (`do_draw`), а также логику атаки (`do_attack_card`) и защиты (`do_defence_card`). Этот модуль является ядром игровой механики.
        *   `result.py`: Отвечает за формирование `InlineQueryResult` для ответов в инлайн-режиме Telegram. Этот модуль создает визуальные элементы, с которыми взаимодействует игрок: отображение карт (играбельных и неактивных), кнопок "Пас" (`add_pass`), "Взять" (`add_draw`), а также информационных сообщений о состоянии игры (`add_gameinfo`, `add_no_game`).
        *   `utils.py`: Набор вспомогательных функций-утилит, в основном предназначенных для проверки прав доступа. Включает функции для проверки, является ли пользователь создателем игры (`user_is_creator`), администратором бота (`user_is_bot_admin`) или администратором чата (`user_is_admin`).
    *   `objects/`: Классы, описывающие основные сущности (модели данных) игры.
        *   `card.py`: Определяет класс `Card` для представления игральной карты. **Ключова частина - `ThemeManager`**, синглтон, що динамічно завантажує та кешує теми з директорії `decks/`. Надає централізований метод `get_sticker_id` для отримання `file_id` стікера за назвою теми та стилем.
        *   `decks/`: Новая директория, содержащая файлы тем для карт. Каждая тема - это `.py` файл со словарем `THEME`.
        *   `deck.py`: Реализует класс `Deck`, управляющий игровой колодой. Отвечает за создание стандартной колоды, её тасование (`shuffle`), определение козыря (`_set_trump`), раздачу карт (`draw`) и сброс отбитых карт (`dismiss`).
        *   `errors.py`: Содержит определения кастомных классов исключений (например, `DeckEmptyError`, `NoGameInChatError`), которые используются для обработки специфических игровых ситуаций и ошибок. Это помогает сделать логику более предсказуемой и управляемой.
        *   `game.py`: Содержит класс `Game` — ядро одной игровой сессии. Этот класс управляет всем состоянием игры: отслеживает игроков (`players`), колоду (`deck`), карты на игровом поле (`field`), козырь (`trump`), а также очередность ходов. Методы класса отвечают за старт игры, атаку (`attack`), защиту (`defend`), переход хода (`turn`) и пополнение рук игроков.
        *   `player.py`: Реализует класс `Player`, представляющий участника игры. Хранит информацию о пользователе Telegram (`user`) и его картах в руке (`cards`). Содержит ключевую логику для определения доступных для хода карт (`playable_card_atk`, `playable_card_def`) и правил, по которым одна карта может побить другую (`can_beat`).
*   `documentation/`: Папка с документацией проекта.
    *   `instructions.md`: Этот самый файл с инструкциями.
*   `img/`: Папка для хранения всех графических ассетов, используемых в боте. Изображения напрямую не встраиваются в код, но их идентификаторы (file_id) кешируются в `durak/objects/card.py` для быстрой отправки в виде стикеров.
    *   `logo_sticker_pack.png`: Основное изображение для стикерпака бота.
    *   `sprites.png`, `sprites_lowsat.png`: Спрайт-листы, объединяющие изображения всех карт в один файл. `lowsat` версия — с пониженной насыщенностью, используется для отображения неактивных или уже сыгранных карт.
    *   `sprite_512px/`: Содержит отдельные файлы изображений для каждой карты в высоком разрешении (512x512 пикселей).
    *   `sprites_512px_lowsat/`: Аналогично предыдущей, но с изображениями карт с пониженной насыщенностью.
    *   `special/`: Изображения для специальных игровых действий, таких как "Взять" (`draw.png`) или "Пас".

## Залежності та функції у структурі проекту

Нижче наведено повний перелік файлів та каталогів, що складають проект. Ця структура допоможе зрозуміти архітектуру та залежності між різними компонентами.

*   `CHANGELOG.md`
*   `bot.py`
    *   **Призначення:** Основна точка входу в додаток.
    *   **Основні дії:**
        *   Ініціалізує та запускає Telegram-бота.
        *   Реєструє кастомний фільтр `IsAdminFilter`.
        *   Імпортує та підключає всі обробники команд з `durak/handlers`.
        *   Запускає `executor.start_polling` для отримання оновлень від Telegram.
    *   **Ключові залежності:** `loader.dp`, `loader.bot`, `durak.filters.IsAdminFilter`, `durak.handlers`.
*   `commands.txt`
*   `config.py`
*   `env`
*   `loader.py`
    *   **Призначення:** Центральний ініціалізатор основних компонентів програми.
    *   **Створювані об'єкти:**
        *   `bot`: Екземпляр `Bot` з `aiogram` для взаємодії з Telegram API.
        *   `dp`: Екземпляр `Dispatcher` з `aiogram` для обробки повідомлень.
        *   `gm`: Екземпляр `GameManager` для керування ігровими сесіями.
    *   **Основні дії:**
        *   Створює та налаштовує глобальні об'єкти `bot`, `dp`, `gm`.
        *   Передає екземпляр `bot` до `GameManager` за допомогою `gm.set_bot(bot)` (ін'єкція залежностей).
        *   Ініціалізує базу даних `durak.sqlite` за допомогою Pony ORM.
        *   Визначає константу `CHOISE` для інлайн-клавіатури.
    *   **Ключові залежності:** `aiogram`, `config`, `durak.logic.game_manager.GameManager`, `durak.db.database.db`.
*   `main.py`
*   `pyproject.toml`
*   `requirements.txt`
*   `ssh-keygen -t ed25519 -C "your_email@example.com"`
*   `ssh-keygen -t ed25519 -C "your_email@example.com".pub`
*   `start.bat`
*   `start.sh`
*   `.idx/`
    *   `dev.nix`
*   `documentation/`
    *   `instructions.md`
*   `durak/`
    *   `__init__.py`
    *   `filters.py`
    *   `db/`
        *   `__init__.py`
        *   `chat_settings.py`
            *   **Призначення:** Визначає модель `ChatSetting` для зберігання налаштувань, специфічних для кожного чату.
            *   **Клас:** `ChatSetting(db.Entity)`
            *   **Поля:**
                *   `id`: ID чату (первинний ключ).
                *   `display_mode`: Режим відображення гри (`text`, `text_and_sticker`).
                *   `card_theme`: Назва обраної теми карт (`classic`, `gold_trumps`).
                *   `is_game_active`: Прапорець, що показує, чи активна гра в цьому чаті.
            *   **Взаємодія:**
                *   **Керується:** З `GameManager` (`_on_game_start_db_session`, `_on_game_end_db_session`) для оновлення статусу `is_game_active`. З `durak/handlers/game_mode.py` для зміни `display_mode`. З `durak/handlers/card_theme.py` для зміни `card_theme`.
        *   `database.py`
            *   **Призначення:** Ініціалізує та надає доступ до об'єкта бази даних `Pony ORM`.
            *   **Об'єкти:**
                *   `db = Database()`: Глобальний екземпляр бази даних.
                *   `session = db_session`: Псевдонім для декоратора `@db_session`, який керує сесіями.
            *   **Взаємодія:** Імпортується у всіх модулях, що працюють з БД (`user_settings.py`, `chat_settings.py`, `loader.py`, `GameManager` та обробниках). Є єдиною точкою входу для роботи з базою даних.
        *   `user_settings.py`
            *   **Призначення:** Визначає модель `UserSetting` для зберігання налаштувань та статистики гравця.
            *   **Клас:** `UserSetting(db.Entity)`
            *   **Поля:**
                *   `id`: ID користувача (первинний ключ).
                *   `stats`: Чи увімкнено збір статистики для гравця.
                *   `is_playing`: Прапорець, що показує, чи грає користувач зараз.
                *   `first_places`, `games_played`: Лічильники перемог та зіграних ігор.
                *   `cards_played`, `cards_beaten`, `cards_atack`: Деталізована статистика дій.
            *   **Взаємодія:**
                *   **Керується:** З `GameManager` для оновлення статусу `is_playing`, з `durak/logic/actions.py` для оновлення ігрової статистики (`win`, `do_attack_card` і т.д.), з `durak/handlers/info/stats.py` для налаштування `stats`.
    *   `handlers/`
        *   `__init__.py`
        *   `card_theme.py`
        *   `game_mode.py`
            *   **Призначення:** Обробляє команду `/gamemode` для зміни режиму відображення гри.
            *   **Функції:**
                *   `set_game_mode(message: types.Message)`: Асинхронна функція, що реагує на команду `/gamemode`.
            *   **Логіка:**
                *   При виклику без аргументів, показує поточний режим та доступні опції.
                *   При виклику з аргументом (`text`, `text_and_sticker`, `sticker_and_button`), оновлює налаштування `display_mode` для поточного чату в базі даних (`ChatSetting`).
            *   **Ключові залежності:** `loader.dp`, `pony.orm.db_session`, `durak.db.chat_settings.ChatSetting`.
        *   `game/`
            *   `__init__.py`
            *   `new.py`
                *   **Призначення:** Обробляє команду `/new` для створення нової гри.
                *   **Логіка:**
                    *   Викликає `gm.new_game(chat, creator=user)` для створення екземпляра гри.
                    *   Надсилає повідомлення з кнопками "Приєднатися" та "Почати гру".
                *   **Взаємодія:** Ініціює ігровий процес, створюючи об'єкт `Game` через `GameManager`.
            *   `join.py`
                *   **Призначення:** Обробляє команду `/join` для приєднання до гри.
                *   **Логіка:** Знаходить гру в поточному чаті та викликає `gm.join_in_game(game, user)`.
                *   **Взаємодія:** Простий обробник, що делегує основну логіку `GameManager`.
            *   `start.py`
                *   **Призначення:** Обробляє команду `/start` для запуску гри.
                *   **Логіка:**
                    *   Перевіряє права користувача (чи є він творцем або адміном).
                    *   Викликає `gm.start_game(game)`.
                    *   Надсилає повідомлення про початок раунду.
                *   **Взаємодія:** Делегує логіку запуску `GameManager`.
            *   `callback_handlers.py`
                *   **Призначення:** Обробляє натискання на інлайн-кнопки, що не пов'язані безпосередньо з ходом гри (наприклад, "Приєднатися", "Почати гру" з `new.py`).
                *   **Взаємодія:** Є проміжною ланкою між натисканням кнопки користувачем та викликом відповідного методу в `GameManager` (наприклад, `gm.join_in_game` або `gm.start_game`).
            *   `chosing.py`
                *   **Призначення:** Основний обробник `inline_query`, відповідальний за відображення ігрового інтерфейсу (карт та кнопок) гравцеві, коли він робить хід.
                *   **Логіка:**
                    *   Отримує інлайн-запит від користувача (`@bot_name ...`).
                    *   Знаходить гру та гравця.
                    *   Перевіряє, чи зараз хід цього гравця.
                    *   Викликає `durak/logic/result.py` для генерації списку `InlineQueryResult` (кольорові стікери для гральних карт, сірі - для неактивних, кнопки "Пас"/"Взяти").
                    *   Відправляє результат Telegram для відображення користувачу.
                *   **Взаємодія:** Тісно пов'язаний з `durak/logic/result.py`, передаючи йому ігровий контекст для візуалізації.
            *   `process_chosen.py`
                *   **Призначення:** Обробляє вибір, зроблений гравцем в інлайн-режимі (коли гравець натискає на карту або кнопку).
                *   **Логіка:**
                    *   Отримує `chosen_inline_result` від Telegram.
                    *   Визначає, яку дію було обрано (атака, захист, пас, взяти).
                    *   Містить **анти-чит** систему для перевірки легітимності ходу.
                    *   Викликає відповідну асинхронну функцію з `durak/logic/actions.py` (наприклад, `do_attack_card`, `do_pass`).
                *   **Взаємодія:** Є "мостом" між вибором користувача в інтерфейсі та виконанням цієї дії в ігровій логіці.
            *   `auto_leave.py`
            *   `global_leave.py`
            *   `join_inline.py`
            *   `kick.py`
            *   `kill.py`
            *   `leave.py`
            *   `start_inline.py`
            *   `test_win.py`
        *   `info/`
            *   `__init__.py`
            *   `get_sticker_id.py`
            *   `help.py`
            *   `stats.py`
    *   `logic/`
        *   `__init__.py`
        *   `actions.py`
            *   **Призначення:** Ядро ігрової механіки. Містить асинхронні функції, що реалізують основні дії в грі (хід, пас, атака, захист), змінюють стан гри та взаємодіють з гравцями.
            *   **Ключові функції:**
                *   `do_turn(game)`: Центральна функція, що керує переходом ходу. Перевіряє наявність переможців, завершення гри та передає хід наступному гравцеві, викликаючи `send_turn_notification`.
                *   `do_attack_card(player, card)`: Обробляє дію атаки. Змінює стан гри через об'єкт `Game`, оновлює статистику та надсилає повідомлення/стікер з атакуючою картою.
                *   `do_defence_card(player, atk_card, def_card)`: Обробляє дію захисту. Аналогічно до атаки, змінює стан, оновлює статистику, видаляє повідомлення про атаку та перевіряє, чи не завершено раунд, щоб викликати `do_turn`.
                *   `do_draw(player)`: Обробляє дію "взяти карти". Гравець `player` (захисник) забирає карти з поля (`game.take_all_field()`), після чого хід передається далі (`do_turn` з `skip_def=True`).
                *   `do_pass(player)`: Обробляє пас від атакуючого. Встановлює `game.is_pass = True` і, якщо всі карти побиті, завершує раунд, викликаючи `do_turn`.
                *   `win(game, player)`: Фіксує перемогу гравця, оновлює його статистику в БД та надсилає вітальне повідомлення.
            *   **Взаємодія:**
                *   **Викликається з:** `durak/handlers/game/process_chosen.py` (коли гравець обирає дію в інлайн-режимі).
                *   **Використовує:** `loader.gm` для доступу до гри, `durak/objects` (змінює стан `Game`, `Player`), `durak/db` (оновлює `UserSetting`).
        *   `game_manager.py`
            *   **Призначення:** Реалізує клас `GameManager` — централізований сервіс для керування життєвим циклом усіх ігрових сесій. Існує у вигляді єдиного екземпляра `gm`, створеного в `loader.py`.
            *   **Клас:** `GameManager`
            *   **Основні методи:**
                *   `new_game(chat, creator)`: Створює нову гру, додає її до словника активних ігор (`self.games`) та оновлює статус гравця в БД.
                *   `get_game_from_chat(chat)`: Повертає об'єкт гри за ID чату.
                *   `end_game(target)`: Завершує гру, видаляє її зі словника та оновлює статус чату і гравців у БД.
                *   `join_in_game(game, user)`: Додає гравця до гри, виконуючи перевірки (гра не почалася, є місце, гравець ще не в грі і т.д.).
                *   `start_game(game)`: Запускає гру, викликаючи метод `game.start()`.
                *   `is_user_in_any_game(user_id)`: Перевіряє, чи бере користувач участь у будь-якій активній грі (в пам'яті).
            *   **Взаємодія:**
                *   **Використовується:** Практично всіма обробниками в `durak/handlers/game/` для отримання доступу до об'єкта гри.
                *   **Керує:** Життєвим циклом об'єктів `durak.objects.Game`.
                *   **Взаємодіє з БД:** Через приватні синхронні методи (`_..._db_session`) для оновлення `ChatSetting` та `UserSetting`.
        *   `result.py`
            *   **Призначення:** Відповідає за візуальне представлення ігрових опцій в інлайн-режимі. Генерує список `InlineQueryResult`, тобто стікери карт та кнопок ("Пас", "Взяти").
            *   **Основні функції:**
                *   `add_card(..., can_play)`: Додає стікер карти. Якщо `can_play` - `True`, стікер буде кольоровим і клікабельним, інакше - сірим і неактивним.
                *   `add_draw(player, results)`: Додає опцію "Взяти карти".
                *   `add_pass(results, game)`: Додає опцію "Пас".
                *   `add_no_game`, `add_not_started`: Додають інформаційні повідомлення.
                *   `game_info(game)`: Формує текстовий контент з повною інформацією про стан гри.
            *   **Взаємодія:**
                *   **Викликається з:** `durak/handlers/game/chosing.py` для формування відповіді на інлайн-запит.
                *   **Використовує:** `durak/objects` для отримання даних про стан гри (`Game`, `Player`, `Card`), але не змінює його.
        *   `utils.py`
            *   **Призначення:** Набір простих допоміжних функцій, переважно для перевірки прав доступу користувачів.
            *   **Основні функції:**
                *   `user_is_creator(user, game)`: Перевіряє, чи є користувач творцем гри.
                *   `user_is_bot_admin(user)`: Перевіряє, чи є користувач адміном бота.
                *   `user_is_admin(user, chat)`: Асинхронно перевіряє, чи є користувач адміном чату.
                *   `user_is_creator_or_admin(...)`: Комбінована перевірка.
            *   **Взаємодія:**
                *   **Використовується:** Різними обробниками в `durak/handlers/` для обмеження доступу до команд (`/kick`, `/kill`, `/gamemode`).
    *   `objects/`
        *   `__init__.py`
        *   `card.py`
            *   **Призначення:** Визначає базові властивості гральної карти та керує її візуальним представленням.
            *   **Клас:** `Card` - представляє одну карту з її номіналом (`value`) та мастю (`suit`).
            *   **Перерахування (Enums):** `Suits`, `Values` - стандартизують масті та номінали, запобігаючи помилкам.
            *   **Динамічні теми:** Файл реалізує механізм завантаження тем для карт з директорії `decks/`. Змінна `ACTIVE_THEME` дозволяє легко перемикати зовнішній вигляд карт.
            *   **Взаємодія:**
                *   **Використовується:** У всіх компонентах, що працюють з картами (`Deck`, `Player`, `Game`, `logic`, `handlers`).
                *   **Залежить від:** `durak/objects/decks/` для завантаження тем.
        *   `deck.py`
            *   **Призначення:** Моделює ігрову колоду.
            *   **Клас:** `Deck`
            *   **Основні методи:**
                *   `_fill_cards()`: Наповнює колоду 36 картами.
                *   `shuffle()`: Перемішує карти.
                *   `_set_trump()`: Визначає козир.
                *   `draw()`: Витягує одну карту з колоди. Викликає виключення `DeckEmptyError`, якщо колода порожня.
                *   `dismiss(card)`: Переміщує карту у відбій (`beaten`).
            *   **Взаємодія:**
                *   **Керується:** Класом `Game`, який створює екземпляр `Deck` для кожної партії.
        *   `errors.py`
            *   **Призначення:** Централізоване визначення кастомних виключень (exceptions), специфічних для ігрової логіки. Це дозволяє більш чисто обробляти помилкові ситуації в коді.
            *   **Приклади виключень:** `DeckEmptyError`, `NoGameInChatError`, `AlreadyJoinedError`, `GameStartedError`.
            *   **Взаємодія:** Виключення з цього файлу використовуються по всьому проекту (переважно в `logic` та `handlers`) для сигналізації про специфічні ігрові помилки.
        *   `game.py`
            *   **Призначення:** Центральний клас, що моделює одну ігрову сесію. Є “серцем” шару моделей даних, оскільки агрегує всі інші об'єкти (`Player`, `Deck`) і керує ними.
            *   **Клас:** `Game`
            *   **Ключові атрибути:** `players` (список гравців), `deck` (колода), `field` (карти на столі), `trump` (козир), `attacker_index` (черга ходу).
            *   **Основні методи:**
                *   `start()`: Починає гру, роздає карти.
                *   `attack(card)`, `defend(atk_card, def_card)`: Змінюють стан ігрового поля (`field`).
                *   `turn()`: Керує логікою переходу ходу.
                *   `take_cards_from_deck()`: Роздає карти гравцям наприкінці раунду.
            *   **Взаємодія:**
                *   **Керується:** `GameManager` (`durak/logic/game_manager.py`), який створює та знищує об'єкти `Game`.
                *   **Агрегує:** `Player` та `Deck`.
                *   **Використовується:** `actions.py` та `result.py` для виконання дій та відображення стану.
        *   `player.py`
            *   **Призначення:** Моделює гравця в партії.
            *   **Клас:** `Player`
            *   **Ключові атрибути:** `user` (об'єкт `aiogram.types.User`), `cards` (карти в руці).
            *   **Основні методи:**
                *   `playable_card_atk()`, `playable_card_def(atk_card)`: Визначають, якими картами гравець може ходити (атакувати або захищатися).
                *   `can_beat(atk_card, def_card)`: Перевіряє, чи може одна карта побити іншу.
                *   `draw_cards_from_deck()`: Добирає карти з колоди.
            *   **Взаємодія:**
                *   **Керується:** Класом `Game`, який створює та керує списком об'єктів `Player`.
        *   `decks/`
            *   `__init__.py`
            *   `classic.py`
            *   `gold_trumps.py`
*   `img/`
    *   `logo_sticker_pack.png`
    *   `sprites.png`
    *   `sprites_lowsat.png`
    *   `special/`
        *   `draw.png`
        *   `info.png`
    *   `sprite_512px/`
    *   `sprites_512px_lowsat/`

## Управление стикерами карт
Все изображения в игре, включая карты, колоду и специальные действия, представлены в виде Telegram-стикеров. Идентификаторы (`file_id`) этих стикеров хранятся в файле `durak/objects/card.py`.

Чтобы добавить или обновить изображение для карты, выполните следующие шаги:

1.  **Отправьте изображение боту**: Отправьте изображение (как фото, не как файл) в личные сообщения боту от имени администратора.
2.  **Получите `file_id`**: Бот в ответ пришлет вам сообщение, содержащее `file_id` для этого изображения.
3.  **Обновите код**: Скопируйте полученный `file_id` и вставьте его в соответствующее место в файле `durak/objects/card.py`.

    *   Для обычных карт: `CARDS['normal']`
    *   Для "серых" (неактивных) карт: `CARDS['grey']`
    *   Для изображений колоды: `DECK`
    *   Для изображений мастей: `SUIT`
    *   Для специальных действий (`Взять`, `Пас`): `SPECIAL`

Например, чтобы обновить изображение для шестерки бубен, найдите ключ `'6_d'` в словаре `CARDS['normal']` и замените его значение на новый `file_id`.

## Стиль кода

Для поддержания чистоты и единообразия кода в этом проекте используется автоматическое форматирование с помощью `black` и проверка стиля с помощью `flake8`.

## Планы на будущее

*   Добавить новые игровые режимы.
*   Улучшить искусственный интеллект ботов.
*   Добавить возможность настройки правил игры.

## Логирование и история изменений

### История изменений (`CHANGELOG.md`)

Для отслеживания всех значимых изменений в проекте используется файл `CHANGELOG.md`, расположенный в корневой директории. В нем фиксируются новые функции, исправления ошибок, изменения в конфигурации и другие важные обновления. Это помогает всем участникам разработки быть в курсе эволюции проекта.

### Логирование работы бота

Логирование — критически важный инструмент для отладки и мониторинга работы бота. Оно позволяет отслеживать ошибки, анализировать поведение пользователей и диагностировать проблемы.

Рекомендуется настроить логирование в главном файле `bot.py` с использованием стандартной библиотеки `logging`.

**Пример базовой конфигурации логирования:**

```python
import logging
import sys

# ... другие импорты

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(name)s - %(message)s',
    handlers=[
        logging.FileHandler("bot.log"),  # Запись логов в файл
        logging.StreamHandler(sys.stdout) # Вывод логов в консоль
    ]
)

# ... остальной код в bot.py
async def main():
    # ...
    logging.info("Бот запускается...")
    await dp.start_polling(bot)

if __name__ == '__main__':
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        logging.info("Бот остановлен.")
```
### Зразок ефективного звіту про помилку

Щоб прискорити діагностику та вирішення проблем, важливо надавати максимально повний контекст. Нижче наведено зразок, як слід формулювати запит, щоб уникнути плутанини та прискорити роботу. Цей приклад є дидактичним матеріалом і не повинен сприйматися мною як реальна команда.

> **Приклад гарного звіту, поданого мені:**
> 
> > перечитай відкриті два файли, цей чат та ось тобі логи запуску
> > 
> > ```
> > [...Повний traceback помилки тут...]
> > ```
> > 
> > і думаю що ти знов намагавс самовільно додати функціонал
> > 
> > глибоко проаналізуй всю інформацію
> 
> **Чому цей звіт є ефективним:**
> 
> 1.  **Чітка команда:** Вказує, що потрібно зробити (`перечитай`, `проаналізуй`).
> 2.  **Надання контексту:** Згадує `відкриті файли` та `цей чат`, що дозволяє відновити історію дій.
> 3.  **Повні логи:** Містить `traceback` помилок.
> 4.  **Формулювання гіпотези:** Припущення допомагає зрозуміти хід думок.

